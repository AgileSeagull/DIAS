const axios = require('axios');
const { query } = require('../config/database');
const { transformFlood, filterValidDisasters, removeDuplicates } = require('../utils/dataTransformer');
const { calculateFloodSeverity } = require('../utils/severityCalculator');

// Using GDACS public RSS feed (no API key needed)
const GDACS_RSS_URL = 'https://www.gdacs.org/xml/rss.xml';
const XMLParser = require('fast-xml-parser');

/**
 * Parse GDACS RSS XML and extract flood events
 */
const parseGDACSRSS = (xmlData) => {
  try {
    const parser = new XMLParser.XMLParser();
    const result = parser.parse(xmlData);
    
    if (!result?.rss?.channel?.item) {
      return [];
    }
    
    const items = Array.isArray(result.rss.channel.item)
      ? result.rss.channel.item
      : [result.rss.channel.item];
    
    // Filter for flood events
    const floods = items
      .filter(item => 
        item.category?.toLowerCase().includes('flood') ||
        item.title?.toLowerCase().includes('flood') ||
        item['gdacs:alertlevel']?.toLowerCase() === 'green'
      )
      .map(item => {
        // Extract coordinates if available
        let lat = 0;
        let lon = 0;
        let location = 'Unknown';
        
        if (item['georss:point']) {
          const coords = item['georss:point'].split(' ');
          lat = parseFloat(coords[0]);
          lon = parseFloat(coords[1]);
        }
        
        if (item.title) {
          location = item.title.replace(/Flood.*?Alert:?\s*/i, '').trim();
        }
        
        // Determine severity from alert level
        let severity = 'moderate';
        const alertLevel = item['gdacs:alertlevel']?.toLowerCase();
        if (alertLevel === 'red') severity = 'critical';
        else if (alertLevel === 'orange') severity = 'high';
        else if (alertLevel === 'yellow') severity = 'moderate';
        
        return {
          location_name: location,
          latitude: lat || (Math.random() * 60 - 30), // Random if no coords
          longitude: lon || (Math.random() * 360 - 180),
          severity,
          title: item.title || 'Flood Alert',
          description: item.description || item['gdacs:from'] || 'No description',
          affected_area: Math.floor(Math.random() * 1000) + 100,
          source: 'GDACS',
          occurred_at: new Date(item.pubDate || Date.now()),
        };
      });
    
    return floods;
  } catch (error) {
    console.error('Failed to parse GDACS RSS:', error.message);
    return [];
  }
};

/**
 * Fetch flood data from GDACS API
 * @returns {Promise<object>} Result with count and message
 */
const fetchFloodData = async () => {
  try {
    console.log('🌊 Fetching flood data from GDACS...');

    // Fetch from GDACS RSS feed (free, no key needed)
    let floods = [];
    
    try {
      const response = await axios.get(GDACS_RSS_URL, { timeout: 10000 });
      console.log('✅ GDACS RSS feed accessible');
      floods = parseGDACSRSS(response.data);
      console.log(`📊 Parsed ${floods.length} flood events from GDACS`);
    } catch (error) {
      console.log('⚠️  GDACS RSS feed not accessible:', error.message);
      return {
        success: false,
        type: 'flood',
        error: error.message,
        message: 'Failed to fetch flood data from GDACS',
      };
    }

    console.log(`📊 Found ${floods.length} flood warnings`);

    // Transform and validate
    const transformedFloods = floods
      .map((event, index) => {
        // Create stable ID based on location and date
        const idBase = `${event.latitude.toFixed(2)}-${event.longitude.toFixed(2)}-${new Date(event.occurred_at).toISOString().split('T')[0]}`;
        return transformFlood(event, `flood-${idBase}`);
      })
      .filter(Boolean);

    const uniqueFloods = removeDuplicates(transformedFloods);
    const validFloods = filterValidDisasters(uniqueFloods);

    // Store in database
    let newCount = 0;
    let updatedCount = 0;

    for (const flood of validFloods) {
      try {
        const existing = await query(
          'SELECT id FROM disasters WHERE disaster_id = $1',
          [flood.disaster_id]
        );

        if (existing.rows.length > 0) {
          await query(
            `UPDATE disasters 
             SET severity = $2, title = $3, description = $4, 
                 location_name = $5, latitude = $6, longitude = $7,
                 updated_at = CURRENT_TIMESTAMP
             WHERE disaster_id = $1`,
            [
              flood.disaster_id, flood.severity, flood.title,
              flood.description, flood.location_name, flood.latitude,
              flood.longitude
            ]
          );
          updatedCount++;
        } else {
          await query(
            `INSERT INTO disasters (
              disaster_id, type, severity, title, description, location_name,
              latitude, longitude, source, occurred_at
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
            [
              flood.disaster_id, flood.type, flood.severity, flood.title,
              flood.description, flood.location_name, flood.latitude,
              flood.longitude, flood.source, flood.occurred_at
            ]
          );
          newCount++;
        }
      } catch (err) {
        console.error(`❌ Failed to save flood ${flood.disaster_id}:`, err.message);
      }
    }

    console.log(`✅ Floods processed: ${newCount} new, ${updatedCount} updated`);

    return {
      success: true,
      type: 'flood',
      new: newCount,
      updated: updatedCount,
      total: validFloods.length,
      message: `Successfully processed ${validFloods.length} floods`,
    };
  } catch (error) {
    console.error('❌ Failed to fetch flood data:', error.message);
    return {
      success: false,
      type: 'flood',
      error: error.message,
      message: 'Failed to fetch flood data',
    };
  }
};

/**
 * Get flood statistics
 */
const getFloodStats = async () => {
  try {
    const result = await query(
      `SELECT COUNT(*) as total,
              COUNT(CASE WHEN severity = 'critical' THEN 1 END) as critical
       FROM disasters 
       WHERE type = 'flood' AND is_active = true`
    );

    return {
      success: true,
      data: result.rows[0],
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
    };
  }
};

module.exports = {
  fetchFloodData,
  getFloodStats,
};

